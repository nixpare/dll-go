// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
mkwinsyscall generates windows system call bodies

It parses all files specified on command line containing function
prototypes (like syscall_windows.go) and prints system call bodies
to standard output.

The prototypes are marked by lines beginning with "//sys" and read
like func declarations if //sys is replaced by func, but:

  - The parameter lists must give a name for each argument. This
    includes return parameters.

  - The parameter lists must give a type for each argument:
    the (x, y, z int) shorthand is not allowed.

  - If the return parameter is an error number, it must be named err.

  - If go func name needs to be different from its winapi dll name,
    the winapi name could be specified at the end, after "=" sign, like
    //sys LoadLibrary(libname string) (handle uint32, err error) = LoadLibraryA

  - Each function that returns err needs to supply a condition, that
    return value of winapi will be tested against to detect failure.
    This would set err to windows "last-error", otherwise it will be nil.
    The value can be provided at end of //sys declaration, like
    //sys LoadLibrary(libname string) (handle uint32, err error) [failretval==-1] = LoadLibraryA
    and is [failretval==0] by default.

  - If the function name ends in a "?", then the function not existing is non-
    fatal, and an error will be returned instead of panicking.

Usage:

	mkwinsyscall [flags] [path ...]

The flags are:

	-output
		Specify output file name (outputs to console if blank).
	-trace
		Generate print statement after every syscall.
*/
package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"text/template"
)

var (
	filename       = flag.String("output", "", "output file name (standard output if omitted)")
	printTraceFlag = flag.Bool("trace", false, "generate print statement after every syscall")
)

func trim(s string) string {
	return strings.Trim(s, " \t")
}

var packageName string

func packagename() string {
	return packageName
}

func windowsdot() string {
	if packageName == "windows" {
		return ""
	}
	return "windows."
}

func syscalldot() string {
	if packageName == "syscall" {
		return ""
	}
	return "syscall."
}

// join concatenates parameters ps into a string with sep separator.
// Each parameter is converted into string by applying fn to it
// before conversion.
func join[T any](ps []T, fn func(T) string, sep string) string {
	if len(ps) == 0 {
		return ""
	}
	a := make([]string, 0)
	for _, p := range ps {
		a = append(a, fn(p))
	}
	return strings.Join(a, sep)
}

// Generate output source file from a source set src.
func (src *Source) Generate(w io.Writer) error {
	funcMap := template.FuncMap{
		"packagename": packagename,
		"syscalldot":  syscalldot,
		"newlazydll": func(dll string) string {
			return syscalldot() + "NewLazyDLL(\"" + dll + ".dll\")"
		},
	}
	t := template.Must(template.New("main").Funcs(funcMap).Parse(srcTemplate))
	err := t.Execute(w, src)
	if err != nil {
		return errors.New("Failed to execute template: " + err.Error())
	}
	return nil
}

func writeTempSourceFile(data []byte) (string, error) {
	f, err := os.CreateTemp("", "mkwinsyscall-generated-*.go")
	if err != nil {
		return "", err
	}
	_, err = f.Write(data)
	if closeErr := f.Close(); err == nil {
		err = closeErr
	}
	if err != nil {
		os.Remove(f.Name()) // best effort
		return "", err
	}
	return f.Name(), nil
}

func usage() {
	fmt.Fprintf(os.Stderr, "usage: mkwinsyscall [flags] [path ...]\n")
	flag.PrintDefaults()
	os.Exit(1)
}

func main() {
	flag.Usage = usage
	flag.Parse()
	if len(flag.Args()) <= 0 {
		fmt.Fprintf(os.Stderr, "no files to parse provided\n")
		usage()
	}

	src, err := ParseFiles(flag.Args())
	if err != nil {
		log.Fatal(err)
	}

	var buf bytes.Buffer
	if err := src.Generate(&buf); err != nil {
		log.Fatal(err)
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("failed to format source: %v", err)
		f, err := writeTempSourceFile(buf.Bytes())
		if err != nil {
			log.Fatalf("failed to write unformatted source to file: %v", err)
		}
		log.Fatalf("for diagnosis, wrote unformatted source to %v", f)
	}
	if *filename == "" {
		_, err = os.Stdout.Write(data)
	} else {
		err = os.WriteFile(*filename, data, 0644)
	}
	if err != nil {
		log.Fatal(err)
	}
}

// TODO: use println instead to print in the following template
const srcTemplate = `

{{define "main"}}
// Code generated by 'go generate'; DO NOT EDIT.
package {{packagename}}

import "C"
import (
{{range .StdLibImports}}
	"{{.}}"
{{end}}

{{range .ExternalImports}}
	"{{.}}"
{{end}}
)

var _ unsafe.Pointer

var (
	{{template "dlls" .}}
	{{template "funcnames" .}}
)

{{range .Funcs}}
	{{template "funcbody" .}}
	{{template "helperbody" .}}
{{end}}

{{end}}	{{/* END MAIN */}}

{{/* TEMPLATE FUNCTIONS */}}

{{define "dlls"}}
{{range .DLLs}}
	mod{{.Var}} = {{newlazydll .Name}}
{{end}}{{end}}

{{define "funcnames"}}
{{range .DLLFuncNames}}
	proc{{.DLLFuncName}} = mod{{.DLLVar}}.NewProc("_{{.DLLFuncName}}")
{{end}}{{end}}

{{define "funcbody"}}
func {{.DLLFuncName}}({{.ParamList}}) {{.Rets.List}} {
	{{template "syscall" .}}
	{{.Rets.SetErrorCode}}
	{{template "printtrace" .}}
	return
}
{{end}}

{{define "helperbody"}}
//export _{{.DLLFuncName}}
func _{{.DLLFuncName}}({{.HelperParamList}}) {{.Rets.HelperList}} {
	{{.HelperCallResultList}} := {{.Name}}({{.HelperCallParamList}})
	{{.HelperCallResultResolv}}
	return 
}
{{end}}

{{define "syscall"}}{{.Rets.SetReturnValuesCode}}{{syscalldot}}SyscallN(proc{{.DLLFuncName}}.Addr(), {{.SyscallParamList}}){{end}}

{{define "printtrace"}}
{{if .PrintTrace}}
	print("SYSCALL: {{.DLLFuncName}}(", {{.ParamPrintList}}") (", {{.Rets.PrintList}}")\n")
{{end}}{{end}}

`